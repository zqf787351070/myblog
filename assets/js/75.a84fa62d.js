(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{1127:function(a,s,t){"use strict";t.r(s);var e=t(6),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_1-mybatis-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-mybatis-是什么"}},[a._v("#")]),a._v(" 1. MyBatis 是什么？")]),a._v(" "),t("p",[a._v("MyBatis 是一个半ORM（对象关系映射）框架，其内部封装了 JDBC，开发是只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等复杂的过程。")]),a._v(" "),t("p",[a._v("通过直接编写原生态 SQL，可以严格控制 SQL 语句的执行性能，支持动态 SQL，灵活度高。")]),a._v(" "),t("p",[a._v("MyBatis 使用 XML 或注解来配置和映射原生信息，将实体类映射成数据库中的记录，避免了 JDBC 代码手动设置参数以及获取结果集的繁琐步骤。")]),a._v(" "),t("p",[a._v("MyBatis 通过 XML 或注解将要执行的各种 statement 进行配置，通过 Java 对象和 statement 中的动态参数进行映射并最终形成执行的 SQL 语句。最后由 MyBatis 框架执行 SQL 语句，并将结果映射为 Java 对象返回。")]),a._v(" "),t("h2",{attrs:{id:"mybatis-的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-的优缺点"}},[a._v("#")]),a._v(" MyBatis 的优缺点")]),a._v(" "),t("p",[a._v("优点：")]),a._v(" "),t("ul",[t("li",[a._v("基于 SQL 语句编程，十分灵活；SQL 语句写在 XML 文件中，解除 SQL 与业务代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL ，可重用")]),a._v(" "),t("li",[a._v("与 JDBC 相比，消除了大量冗余的代码，不需要手动开关连接")]),a._v(" "),t("li",[a._v("可以很好的与各种数据库兼容")]),a._v(" "),t("li",[a._v("可以很好地与 Spring 集成")])]),a._v(" "),t("p",[a._v("缺点：")]),a._v(" "),t("ul",[t("li",[a._v("SQL 编写工作量大，对开发人员的 SQL 功底有一定要求")]),a._v(" "),t("li",[a._v("SQL 语句依赖数据库，故数据库移植性差，不能随意更换")])]),a._v(" "),t("h2",{attrs:{id:"mybatis-和-hibernate-的对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-和-hibernate-的对比"}},[a._v("#")]),a._v(" MyBatis 和 Hibernate 的对比")]),a._v(" "),t("p",[a._v("针对简单逻辑，Hibernate 和 MyBatis 都有相应的代码生成工具，可以生成简单基本的 DAO 层方法。")]),a._v(" "),t("p",[a._v("针对高级查询，Mybatis 需要手动编写 SQL 语句，以及 ResultMap；而 Hibernate 有良好的映射机制，开发者无需关心 SQL 的生成与结果映射，可以更专注于业务流程。Hibernate 也可以自己写 SQL 来指定需要查询的字段，但这样就破坏了 Hibernate 开发的简洁性。")]),a._v(" "),t("p",[a._v("举个形象的比喻：")]),a._v(" "),t("ul",[t("li",[a._v("Mybatis：机械工具，使用方便，拿来就用，但工作还是要自己来作，不过工具是活的，怎么使由我决定。")]),a._v(" "),t("li",[a._v("Hibernate：智能机器人，但研发它（学习、熟练度）的成本很高，工作都可以摆脱他了，但仅限于它能做的事。")])]),a._v(" "),t("h1",{attrs:{id:"_2-mybatis-的核心组件有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-mybatis-的核心组件有哪些"}},[a._v("#")]),a._v(" 2. MyBatis 的核心组件有哪些？")]),a._v(" "),t("p",[a._v("MyBatis 核心组件包括 SqlSessionFactoryBuilder / SqlSessionFactory / SqlSession / Mapper。")]),a._v(" "),t("h2",{attrs:{id:"sqlsessionfactorybuilder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sqlsessionfactorybuilder"}},[a._v("#")]),a._v(" SqlSessionFactoryBuilder")]),a._v(" "),t("p",[a._v("SqlSessionFactoryBuilder 是一个构建器，用于构建 SqlSessionFactory。其生命周期一般只存在于方法的局部，用完即可收回。")]),a._v(" "),t("p",[a._v("构建语句：\n"),t("code",[a._v("SqlSessionFactory factory = SqlSessionFactoryBuilder.build(inputStream);")])]),a._v(" "),t("h2",{attrs:{id:"sqlsessionfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sqlsessionfactory"}},[a._v("#")]),a._v(" SqlSessionFactory")]),a._v(" "),t("p",[a._v("SqlSessionFactory 用于创建 SqlSession，即创建一个对话。")]),a._v(" "),t("p",[a._v("每次程序访问数据库，都需要使用 SqlSession，所以 SqlSessionFactory 应该存在于 MyBatis 应用的整个生命周期中。")]),a._v(" "),t("p",[a._v("为了减少创建会话带来的资源消耗，一般使用单例模式创建 SqlSession。")]),a._v(" "),t("p",[a._v("创建语句：\n"),t("code",[a._v("SqlSession sqlSession = SqlSessionFactory.openSession();")])]),a._v(" "),t("h2",{attrs:{id:"sqlsession"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sqlsession"}},[a._v("#")]),a._v(" SqlSession")]),a._v(" "),t("p",[a._v("SqlSession 就是一个对话，既可以发送 SQL 语句去执行返回结果，也可以代理 Mapper 接口。")]),a._v(" "),t("p",[a._v("SqlSession 是一个线程不安全的对象，其生命周期应该在请求数据库处理事务的过程中。")]),a._v(" "),t("p",[a._v("每次创建的 SqlSession 对象应该及时关闭，否则会使得数据库连接池的活动资源变少，影响系统性能。")]),a._v(" "),t("h2",{attrs:{id:"mapper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mapper"}},[a._v("#")]),a._v(" Mapper")]),a._v(" "),t("p",[a._v("Mapper 用于 MyBatis 代理 DAO，通过注解和 XML 文件可以获取对应的 SQL 和映射规则。")]),a._v(" "),t("p",[a._v("使用语句：\n"),t("code",[a._v("XXMapper xxMapper = sqlSession.getMapper(XXMapper.class);")])]),a._v(" "),t("h1",{attrs:{id:"_3-mybatis-的动态-sql-有了解么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-mybatis-的动态-sql-有了解么"}},[a._v("#")]),a._v(" 3. MyBatis 的动态 SQL 有了解么？")]),a._v(" "),t("p",[a._v("MyBatis 可以在 xml 映射文件中以标签的形式实现动态 SQL，其原理是根据表达式的值完成逻辑判断并动态拼接 SQL 语句。")]),a._v(" "),t("h2",{attrs:{id:"动态-sql-标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态-sql-标签"}},[a._v("#")]),a._v(" 动态 SQL 标签")]),a._v(" "),t("ul",[t("li",[a._v("if：单条件分支的判断语句")]),a._v(" "),t("li",[a._v("choose, when, otherwise：多条件的分支判断语句")]),a._v(" "),t("li",[a._v("foreach：列举条件，遍历集合，实现循环语句")]),a._v(" "),t("li",[a._v("trim,where,set：是一些辅助元素，可以对拼接的SQL进行处理")]),a._v(" "),t("li",[a._v("bind：进行模糊匹配查询的时候使用，提高数据库的可移植性")])]),a._v(" "),t("h1",{attrs:{id:"_4-mybatis-的-mapper-中常用标签有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-mybatis-的-mapper-中常用标签有哪些"}},[a._v("#")]),a._v(" 4. Mybatis 的 Mapper 中常用标签有哪些？")]),a._v(" "),t("ul",[t("li",[a._v("| select | insert | update | delete |")]),a._v(" "),t("li",[a._v("| resultMap | resultType |")]),a._v(" "),t("li",[a._v("| where | if | foreach | sql |")])]),a._v(" "),t("h1",{attrs:{id:"_5-mybatis-的-dao-接口的工作原理有了解么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-mybatis-的-dao-接口的工作原理有了解么"}},[a._v("#")]),a._v(" 5. MyBatis 的 DAO 接口的工作原理有了解么？")]),a._v(" "),t("p",[a._v("DAO 接口即 Mapper 接口。接口的全限名就是映射文件中 namespace 的值；接口的方法名，就是映射文件中的 id 值；接口方法内的参数，就是传递给 SQL 的参数。")]),a._v(" "),t("p",[a._v("Mapper 接口没有实现类，调用接口方法的时候，使用接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个 MapperStatement。在 MyBatis 中，每一个"),t("code",[a._v("<select>、<insert>、<update>、<delete>")]),a._v("标签，都会被解析为一个 MapperStatement对象。")]),a._v(" "),t("p",[a._v("Mapper 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Mapper 接口生成代理对象 proxy，代理对象会拦截接口方法，转而执行 MapperStatement 所代表的 SQL，然后将 SQL 执行结果返回。")]),a._v(" "),t("h2",{attrs:{id:"dao-接口中的方法可以重载么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dao-接口中的方法可以重载么"}},[a._v("#")]),a._v(" DAO 接口中的方法可以重载么？")]),a._v(" "),t("p",[a._v("不可以。因为 xml 文件中使用的是全限名 + 方法名的保存和寻找策略。")]),a._v(" "),t("h2",{attrs:{id:"不同映射文件-xml-中的-id-可以重复么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同映射文件-xml-中的-id-可以重复么"}},[a._v("#")]),a._v(" 不同映射文件 xml 中的 id 可以重复么？")]),a._v(" "),t("p",[a._v("如果配置了 namesapce，那么 id 可以重复； 如果没有配置，则不可以重复。")]),a._v(" "),t("h1",{attrs:{id:"_6-mybatis-中-和-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-mybatis-中-和-的区别"}},[a._v("#")]),a._v(" 6. MyBatis 中 # 和 $ 的区别")]),a._v(" "),t("p",[a._v("能用 # 就尽量不用 $")]),a._v(" "),t("ul",[t("li",[a._v("# 是预编译处理，是占位符；$ 是字符串替换，是拼接符")]),a._v(" "),t("li",[a._v("Mybatis 在处理 # 时，会将 sql 中的 # 替换为 ？，并调用 PreparedStatement 来赋值；在处理 $ 是，就是把 $ 替换成变量的值，调用 Statement 来赋值")]),a._v(" "),t("li",[a._v("# 变量替换替换后，对应的变量会自定添加单引号；$ 变量替换后，对应变量不会添加单引号")]),a._v(" "),t("li",[a._v("使用 # 可以有效防止 SQL 注入，提高系统安全性")])]),a._v(" "),t("h1",{attrs:{id:"_7-mybatis-的缓存机制有了解么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-mybatis-的缓存机制有了解么"}},[a._v("#")]),a._v(" 7. MyBatis 的缓存机制有了解么？")]),a._v(" "),t("p",[a._v("分为一级缓存和二级缓存。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("一级缓存（同一个SqlSession）\n基于 HashMap 的本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有缓存就将清空，默认打开一级缓存。")])]),a._v(" "),t("li",[t("p",[a._v("二级缓存（同一个SqlSessionFactory）\n二级缓存与一级缓存其机制相同，默认也是采用 HashMap 的本地存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源。")])])]),a._v(" "),t("h1",{attrs:{id:"_8-mybatis-的接口绑定是什么-有哪些方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-mybatis-的接口绑定是什么-有哪些方式"}},[a._v("#")]),a._v(" 8. MyBatis 的接口绑定是什么？有哪些方式？")]),a._v(" "),t("p",[a._v("接口绑定即 MyBatis 代理 DAO 接口，将接口里的方法和 xml 映射文件中 SQL 语句绑定。我们在使用的时候直接调用接口方法即可。")]),a._v(" "),t("ul",[t("li",[a._v("注解绑定："),t("code",[a._v("@Select、@Update")])]),a._v(" "),t("li",[a._v("xml 绑定：设置 namespace 为全路径名")])]),a._v(" "),t("h1",{attrs:{id:"_9-mybatis-插件的原理及应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-mybatis-插件的原理及应用"}},[a._v("#")]),a._v(" 9. MyBatis 插件的原理及应用")]),a._v(" "),t("h2",{attrs:{id:"什么是插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是插件"}},[a._v("#")]),a._v(" 什么是插件？")]),a._v(" "),t("p",[a._v("插件是Mybatis中的最重要的功能之一，能够对特定组件的特定方法进行增强。")]),a._v(" "),t("p",[a._v("MyBatis 允许我们在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("「Executor」：update, query, flushStatements, commit, rollback, getTransaction, close, isClosed")])]),a._v(" "),t("li",[t("p",[a._v("「ParameterHandler」: getParameterObject, setParameters")])]),a._v(" "),t("li",[t("p",[a._v("「ResultSetHandler」：handleResultSets, handleOutputParameters")])]),a._v(" "),t("li",[t("p",[a._v("「StatementHandler」: prepare, parameterize, batch, update, query")])])]),a._v(" "),t("h2",{attrs:{id:"如何自定义插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何自定义插件"}},[a._v("#")]),a._v(" 如何自定义插件？")]),a._v(" "),t("p",[a._v("插件的实现其实很简单，只需要实现 Mybatis 提供的 Interceptor 接口即可，源码如下：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Interceptor")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//拦截的方法")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("intercept")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Invocation")]),a._v(" invocation"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Throwable")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//返回拦截器的代理对象")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("plugin")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//设置一些属性")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setProperties")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Properties")]),a._v(" properties"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br")])]),t("p",[a._v("自定义插件使用的注解：")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("@Intercepts")]),a._v("：标注在实现类上，表示这个类是一个插件的实现类。")]),a._v(" "),t("li",[t("code",[a._v("@Signature")]),a._v("：作为"),t("code",[a._v("@Intercepts")]),a._v("的属性，表示需要增强 Mybatis 的某些组件中的某些方法（可以指定多个）。常用的属性如下：\n"),t("ul",[t("li",[t("code",[a._v("Class<?> type()")]),a._v("：指定哪个组件（Executor、ParameterHandler、ResultSetHandler、StatementHandler）")]),a._v(" "),t("li",[t("code",[a._v("String method()")]),a._v("：指定增强组件中的哪个方法，直接写方法名称。")]),a._v(" "),t("li",[t("code",[a._v("Class<?>[] args()")]),a._v("：方法中的参数，必须一一对应，可以写多个；这个属性非常重用，区分重载方法。")])])])]),a._v(" "),t("p",[a._v("完成 Interceptor 接口的实现类后，创建一个配置类，在其中注册该接口实现类的 Bean 并注入 IOC 容器即可。")])])}),[],!1,null,null,null);s.default=r.exports}}]);